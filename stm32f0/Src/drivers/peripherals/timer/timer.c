/*
 * timer.c
 *
 *  Created on: Dec 19, 2024
 *      Author: elias
 */


#include "timer.h"


void init_timer(rcc_tim_t timer){
	rcc_enable_timer(timer);
}


// SIMPLE GUIDE TO DO THAT ACCORDING TO THE DOCUMENT

/*
 * 1) SELECT THE INPUT CAPTURE MODE IN THE CCMR1 REGISTER IN THE CC1S BITS, WHEN THOSE BITS ARE DIFFERENT FROM 00 THEN THE
 * CHANNEL IS SELECTED AS INPUT CAPTURE
 *
 * 2) SELECT THE EDGE TO START A CAPTURE BY SETTING THE CCER REGISTER FOR INPUT CAPTURE THE BITS CCP1 AND CC1NP CAN BE
 * USED TO SELECT THE EDGES SO WE HAVE A LITTLE GAP BETWEEN THE BITS CCP1 = BIT 1 AND CC1NP = BIT 3.
 *
 * WITH THAT KNOWLEDGE WE CAN USE SOMETHING LIKE:
 * 0X0 = RISING EDGE
 * 0X1 = FALLING EDGE
 * 1X1 = BOTH EDGES
 *
 *3) SEE THE PRESCALER BIT CONFIG IN CCMRX
 *4) ENABLE THE INPUT CAPTURE  BY SETTING THE CC1E BIT IN THE CCER REGISTER
 *5) SEE THE INTERRUPT/DMA SECTION
 *
 * */


void init_input_capture(TIM_TypeDef *TIMX, TIM_CHANNEL CH){
	switch(CH){
		case CH1:
			TIMX->CCMR1 |= CCMRX_INPUT_IC1_BIT_0;
			TIMX->CCMR1 &= ~CCMRX_INPUT_IC1_BIT_1;
			break;
		case CH2:
			TIMX->CCMR1 |= CCMRX_INPUT_IC2_BIT_0;
			TIMX->CCMR1 &= ~CCMRX_INPUT_IC2_BIT_1;
			break;
		case CH3:
			TIMX->CCMR2 |= CCMRX_INPUT_IC3_BIT_0;
			TIMX->CCMR2 &= ~CCMRX_INPUT_IC3_BIT_1;
			break;
		case CH4:
			TIMX->CCMR2 |= CCMRX_INPUT_IC4_BIT_0;
			TIMX->CCMR2 &= ~CCMRX_INPUT_IC4_BIT_1;
			break;
		default:
			break;
	}


}
